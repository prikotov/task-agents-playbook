# Стандарт постановки задач для LLM-агентов (Markdown)

Этот документ описывает единый формат постановки задач в `.md` для LLM-агентов, которые **полноценно работают с репозиторием** (читают/пишут файлы, запускают тесты/линтеры).

Цель стандарта: задачи должны быть **точными, проверяемыми, ограниченными по объёму** и не допускать расползания scope.

---

## Термины и расшифровки

### SMART (критерии хорошо сформулированной задачи)
SMART используется здесь как краткая проверка качества формулировки, без “философии”.

- **S — Specific (конкретно):** что именно меняем (функция/поведение/файл/контракт).
- **M — Measurable (измеримо):** как понять, что сделано (тесты, команды, конкретные условия).
- **A — Achievable (достижимо):** реально выполнить с доступными инструментами/правами.
- **R — Relevant (релевантно):** зачем это нужно (ценность).
- **T — Time-bound (ограничено во времени):** дедлайн/релиз/итерация или явное “нет дедлайна”.

> Для LLM-агентов чаще всего критичны **S, M, T**. Остальные — одной строкой.

### User Story (пользовательская история)
Короткая формула “роль → действие → польза”:

> **Как** `<роль>`, **я хочу** `<действие>`, **чтобы** `<польза>`.

Используется, чтобы зафиксировать **зачем** делаем изменение.

### Job Story (ситуационная история, опционально)
Формула “ситуация → действие → результат”:

> **Когда** `<ситуация>`, **я хочу** `<действие>`, **чтобы** `<результат>`.

Используйте **только если важен контекст** “когда/почему”. По умолчанию достаточно User Story.

### MoSCoW (приоритизация требований)
Способ управлять объёмом задачи и явно запрещать лишнее.

- **Must:** обязательно. Без этого задача не принимается.
- **Should:** желательно. Можно отложить, если мешает срокам/объёму.
- **Could:** по возможности. Никаких обещаний.
- **Won’t:** в этой задаче **не делать** (явные запреты, чтобы агент не расползался).

### INVEST (чек качества задачи)
INVEST — проверка, что задача “хорошая” и исполнимая.

- **I — Independent (независимая):** по возможности без скрытых зависимостей; зависимости явно указаны.
- **N — Negotiable (обсуждаемая):** допускает разумные уточнения, но ключевые решения/запреты зафиксированы.
- **V — Valuable (ценная):** понятная польза.
- **E — Estimable (оцениваемая):** можно грубо оценить объём (область изменений обозначена).
- **S — Small (маленькая):** ограниченный scope (лучше несколько задач, чем одна огромная).
- **T — Testable (проверяемая):** есть критерии приёмки + команды проверки.

---

## Принцип “хорошей задачи”

Задача готова для LLM-агента, если выполняются все пункты:

1. **Понятно что сделать** (Specific).
2. **Понятно как проверить** (Measurable + Testable).
3. **Понятно что запрещено делать** (Won’t).
4. **Понятно где менять** (границы в коде).
5. **Понятно в каком объёме** (Small + Estimable).

---

## Обязательный шаблон `.md`-задачи

Скопируйте и заполняйте. Секции 1–7 обязательны.

```md
# <Заголовок: глагол + объект + контекст>
# Пример: "Добавить параметр includeArchived в API списка задач"

## 1) Ценность (User Story / Job Story)
### User Story
Как <роль>,
я хочу <действие>,
чтобы <польза>.

# (Опционально) Job Story — если важна ситуация
# Когда <ситуация>,
# я хочу <действие>,
# чтобы <результат>.

## 2) SMART-сводка (3 строки максимум)
- Specific: <что конкретно меняем>
- Measurable: <как измеряем готовность: тесты/команды/условия>
- Time-bound: <срок/релиз/итерация> (если нет — "нет дедлайна")

## 3) Контекст и границы
- Где в коде: <пути/модули/классы/эндпоинты>
- Текущее поведение: <1–3 предложения>
- Что НЕ трогать (границы): <модули/файлы/публичные контракты>

## 4) Требования (MoSCoW)
### Must
- [ ] ...

### Should
- [ ] ...

### Could
- [ ] ...

### Won’t (важно)
- [ ] ...

## 5) Критерии приёмки (проверяемо, без интерпретаций)
- [ ] ...
- [ ] ...

## 6) Самопроверка (агент обязан выполнить)
```bash
<команды тестов/линта/статанализа>
```

## 7) Definition of Done (когда считать завершённой)
- [ ] Тесты/линт зелёные
- [ ] Нет лишних изменений вне scope
- [ ] Обновлены доки/комментарии (если Must/Should)
```
```

---

## Как писать задачу (процедура)

### Шаг 1 — сформулировать ценность (User Story)
Заполните 3 строки. Это фиксирует **зачем** (Relevant/Valuable).

### Шаг 2 — сделать SMART-сводку (S + M + T)
- **Specific:** одна фраза “что делаем”.
- **Measurable:** один способ проверки (тесты/команды/условия).
- **Time-bound:** дедлайн/релиз или “нет дедлайна”.

> Если нет проверки — задача не готова.

### Шаг 3 — задать контекст и границы
- Где менять (пути/модули/классы).
- Что не трогать (контракты, модули, миграции, зависимости).

### Шаг 4 — ограничить объём через MoSCoW
- В **Must** — только то, без чего нельзя принять задачу.
- В **Won’t** — явные запреты, особенно против “улучшений вокруг”.

Рекомендуемые “запреты по умолчанию” (добавляйте по ситуации):
- Не менять публичные контракты (API/DTO/форматы), кроме явно указанного.
- Не добавлять новые зависимости.
- Не делать рефакторинг “всего рядом” без отдельной задачи.
- Не менять схему БД/миграции, если это не Must.

### Шаг 5 — написать критерии приёмки
Критерии приёмки должны быть **проверяемыми** и не требовать интерпретаций.

Хорошо:
- “При параметре X возвращается Y”
- “Добавлен тест на кейс Z”
- “Команда `composer test` проходит”

Плохо:
- “Сделать красиво/удобно/оптимально” (без метрики)
- “Улучшить качество” (без определения качества)
- “Рефакторинг” (без границ и результата)

### Шаг 6 — указать команды самопроверки
Агент обязан выполнить команды из секции “Самопроверка” и не завершать задачу, пока они не проходят.

---

## Мини-чеклист INVEST перед отдачей агенту (10 секунд)

- **Independent:** зависимости есть? если да — указаны?
- **Small:** Must+Should не раздулись? если больше ~10 пунктов — делить.
- **Testable:** критерии приёмки объективные? есть команды проверки?
- **Won’t:** запреты перечислены?
- **Estimable:** область изменений понятна (где в коде)?

Если на любой вопрос ответ “нет” — задачу доработать.

---

## Примеры (короткие)

### Пример 1 — фича

```md
# Добавить параметр includeArchived в API списка задач

## 1) Ценность (User Story / Job Story)
### User Story
Как пользователь API,
я хочу включать/выключать архивные задачи в выдаче,
чтобы не делать отдельные запросы/фильтры на клиенте.

## 2) SMART-сводка
- Specific: добавить query-параметр includeArchived в эндпоинт списка задач
- Measurable: тесты на выдачу с includeArchived=false/true + прохождение composer test
- Time-bound: нет дедлайна

## 3) Контекст и границы
- Где в коде: src/Module/Tasks/... (контроллер списка, query handler)
- Текущее поведение: архивные задачи всегда исключаются
- Что НЕ трогать: формат JSON-ответа, другие эндпоинты, миграции БД

## 4) Требования (MoSCoW)
### Must
- [ ] Параметр includeArchived (bool), по умолчанию false
- [ ] При includeArchived=true архивные задачи включаются
- [ ] Добавить тесты на оба режима

### Should
- [ ] Обновить документацию эндпоинта (md)

### Could
- [ ] Принимать значения 1/0/true/false

### Won’t
- [ ] Не менять схему ответа
- [ ] Не добавлять новые эндпоинты

## 5) Критерии приёмки
- [ ] Без параметра архивные задачи отсутствуют
- [ ] При includeArchived=true архивные задачи присутствуют
- [ ] composer test проходит

## 6) Самопроверка
```bash
composer test
```
```

### Пример 2 — багфикс

```md
# Исправить падение импорта при пустом поле title

## 1) Ценность
### User Story
Как пользователь импорта,
я хочу, чтобы импорт не падал на записи без title,
чтобы пакетный импорт завершался и обрабатывал остальные записи.

## 2) SMART-сводка
- Specific: обработать пустой title без фатальной ошибки
- Measurable: тест на пустой title + успешное выполнение composer test
- Time-bound: до следующего релиза (если релизы есть; иначе "нет дедлайна")

## 3) Контекст и границы
- Где в коде: src/Module/Import/... (mapper/validator)
- Текущее поведение: исключение прерывает весь импорт
- Что НЕ трогать: формат входного файла, обязательность других полей

## 4) Требования (MoSCoW)
### Must
- [ ] Пустой title не вызывает фатальную ошибку
- [ ] Запись пропускается и фиксируется в отчёте/логе импорта
- [ ] Добавить тест

### Should
- [ ] В отчёте указать идентификатор записи/номер строки

### Could
- [ ] Счётчик пропусков (если инфраструктура уже есть)

### Won’t
- [ ] Не менять формат входного файла
- [ ] Не добавлять новые обязательные поля

## 5) Критерии приёмки
- [ ] Импорт завершает обработку остальных записей
- [ ] Пропуск отражён в отчёте/логе
- [ ] composer test проходит

## 6) Самопроверка
```bash
composer test
```
```

---

## Антипаттерны (что не писать)

- “Сделай рефакторинг” без границ и результата.
- “Оптимизируй” без метрики и способа измерения.
- “Сделай как надо/красиво/удобно” без критериев приёмки.
- “Почини всё, что найдёшь по пути” (противоречит Small и Won’t).

---

## Рекомендация по разбиению больших задач
Если Must включает несколько независимых блоков (API + UI + миграции + документация), делите на задачи так, чтобы каждая оставалась **Small** и **Testable**.
